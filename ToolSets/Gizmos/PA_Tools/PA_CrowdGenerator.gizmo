
Group {
 name PA_CrowdGenerator
 knobChanged "\n\n\n\n\n\n\n#CROWD GENERATOR\n#KNOB CHANGED CHUNK\n#PYTHON SCRIPT CREATED BY PEDRO ANDRADE\n#ALL RIGHTS RESERVED\n#2016\n\n\n\nimport random\n\n\n\n#INPUT NUMBER\n\n#nuke.root().begin\n\n#inputList = \[]\n#for n in nuke.allNodes('Input'):\n #   inputList.append(n.knob('name'))\n#numInputs = int(len(inputList)) - 1\n#nuke.thisNode().knob('inputs').setValue(numInputs)\n\n#nuke.root().end\n\n\n\n#KNOBS VISIBILITY\n\nnuke.thisNode().knob('width').setEnabled(False)\nnuke.thisNode().knob('depth').setEnabled(False)\nnuke.thisNode().knob('total').setEnabled(False)\n#nuke.thisNode().knob('inputs').setEnabled(False)\n\n\n\n#TOTAL VISIBLE\n\nwidthValue = int(nuke.thisNode().knob('width').value())\ndepthValue = int(nuke.thisNode().knob('depth').value())\nnuke.thisNode().knob('total').setValue(int(widthValue*depthValue))\n\n\nif nuke.thisKnob().name() == 'density':\n    densityValue = int(round(nuke.thisNode().knob('density').value()))\n    totalVisibleValue = int(int((widthValue*depthValue*densityValue)/100))\n    nuke.thisNode().knob('total').setValue(totalVisibleValue)\n\n\n\n\n\n\n\n\n#DENSITY\n\nif nuke.thisKnob().name() == 'density':\n\n    with nuke.thisNode():\n    \n        switchNamesList = \[]\n        for n in nuke.allNodes('Switch'):\n            if n.knob('label').value() != 'Input Type':\n                switchNamesList.append(n.name())\n        switchNamesList = list(set(switchNamesList))\n       \n        densityValue = int(nuke.thisNode().knob('density').value())   \n        print densityValue\n        indexDensityValue = int((int(len(switchNamesList)) * densityValue) / 100)\n        print indexDensityValue\n    \n    \n        for n in switchNamesList:\n            dynSwitchNamesList = switchNamesList\[:indexDensityValue]\n            print dynSwitchNamesList\n            for n in dynSwitchNamesList:\n                nuke.toNode(str(n)).knob('which').setValue(0)\n    \n            for n in list(set(switchNamesList) - set(dynSwitchNamesList)):\n                nuke.toNode(str(n)).knob('which').setValue(1)\n                    \n            break\n\n\n\n#SCALE\n\nif nuke.thisKnob().name() == 'scale':\n\n    with nuke.thisNode():\n\n        transformGeoList = \[]\n        for n in nuke.allNodes('TransformGeo'):\n            n.knob('uniform_scale').setValue(nuke.thisNode().knob('scale').value())\n\n\n\n\n\n#XZ DISPLACEMENT\n\n\nif nuke.thisKnob().name() == 'xzdisplacement':\n\n\n    with nuke.thisNode():\n    \n        xzdisplacementValue = nuke.thisNode().knob('xzdisplacement').value()\n    \n      \n        transformGeoList = \[]\n        transformGeoXList = \[]\n        transformGeoZList = \[] \n        for n in nuke.allNodes('TransformGeo'):\n            transformGeoList.append(n.name())\n            transformGeoXList.append(n.knob('translate').value(0))\n            transformGeoZList.append(n.knob('translate').value(2))\n    \n    \n        for n in range(len(transformGeoList)):\n            if int(nuke.toNode(transformGeoList\[n]).knob('name').value()\[len(nuke.toNode(transformGeoList\[n]).knob('name').value())-1]) % 2 == 0:\n                numPolarityRandomList = int(1)\n    \n            else:\n                numPolarityRandomList = int(-1)\n    \n\n            offsetValue = int(transformGeoList\[n]\[len(transformGeoList\[n])-1]) / int(len(transformGeoList))\n    \n            nuke.toNode(transformGeoList\[n]).knob('translate').setValue(transformGeoXList\[n] + (xzdisplacementValue * numPolarityRandomList) + offsetValue, 0)\n            nuke.toNode(transformGeoList\[n]).knob('translate').setValue(transformGeoZList\[n] + (xzdisplacementValue * numPolarityRandomList) + offsetValue, 2)\n\n\n\n\n\n#X SPACING\n\nif nuke.thisKnob().name() == 'xspacing':\n\n    with nuke.thisNode():\n\n        xSpacingValue = float(nuke.thisNode().knob('xspacing').value())\n    \n        transformGeoList = \[]\n        xPosList = \[]\n        for n in nuke.allNodes('TransformGeo'):\n            transformGeoList.append(n.name())\n            xPosList.append(n.knob('translate').value(0))\n\n        uniqueXValues = list(set(xPosList))\n        uniqueXValues.sort()\n        #print uniqueXValues\n        #print len(uniqueXValues)\n\n        organizedList = \[]\n        for n in range(len(uniqueXValues)):        \n            for n2 in nuke.allNodes('TransformGeo'):           \n                if uniqueXValues\[n] == n2.knob('translate').value(0):\n                    organizedList.append(n2.name())\n\n        #print organizedList\n        \n        \n        widthValue = int(nuke.thisNode().knob('width').value())\n        depthValue = int(nuke.thisNode().knob('depth').value())\n        #print widthValue\n        #print depthValue\n\n        chunks = \[organizedList\[x:x+depthValue] for x in xrange(0, len(organizedList), depthValue)]\n        #print chunks\n\n    \n        #print len(chunks\[0])\n        #print chunks\[0]\n\n        #print len(chunks)\n        #print len(chunks\[19])\n        #print chunks\n\n        for n in range(widthValue):\n            #print n\n            for n2 in chunks\[n]:\n             #   print n2\n                try:\n                    nuke.toNode(n2).knob('translate').setValue(uniqueXValues\[n] + (int(n) * (xSpacingValue + 1)) - nuke.toNode(n2).knob('translate').value(0) + 10, 0)\n\n                except:\n                    pass\n\n\n\n\n\n#Y SPACING\n\nif nuke.thisKnob().name() == 'yspacing':\n\n    with nuke.thisNode():\n\n        ySpacingValue = float(nuke.thisNode().knob('yspacing').value())\n    \n        transformGeoList = \[]\n        yPosList = \[]\n        for n in nuke.allNodes('TransformGeo'):\n            transformGeoList.append(n.name())\n            yPosList.append(n.knob('translate').value(2))\n\n        uniqueYValues = list(set(yPosList))\n        uniqueYValues.sort()\n        print uniqueYValues\n        #print len(uniqueYValues)\n\n        organizedList = \[]\n        for n in range(len(uniqueYValues)):        \n            for n2 in nuke.allNodes('TransformGeo'):           \n                if uniqueYValues\[n] == n2.knob('translate').value(2):\n                    organizedList.append(n2.name())\n\n        #print organizedList\n        \n        \n        widthValue = int(nuke.thisNode().knob('width').value())\n        depthValue = int(nuke.thisNode().knob('depth').value())\n        #print widthValue\n        #print depthValue\n\n        chunks = \[organizedList\[x:x+widthValue] for x in xrange(0, len(organizedList), widthValue)]\n        print chunks\n\n    \n        #print len(chunks\[0])\n        #print chunks\[0]\n\n        #print len(chunks)\n        #print len(chunks\[19])\n        #print chunks\n\n        for n in range(depthValue):\n            #print n\n            for n2 in chunks\[n]:\n             #   print n2\n                #print uniqueYValues\[n] + (int(n) * (ySpacingValue + 1)) - nuke.toNode(n2).knob('translate').value(1)\n\n                nuke.toNode(n2).knob('translate').setValue(uniqueYValues\[n] + (int(n) * (ySpacingValue)) - uniqueYValues\[n], 1)\n\n\n\n\n\n\n\n\n#Z SPACING\n\nif nuke.thisKnob().name() == 'zspacing':\n\n    with nuke.thisNode():\n\n        zSpacingValue = float(nuke.thisNode().knob('zspacing').value())\n    \n        transformGeoList = \[]\n        zPosList = \[]\n        for n in nuke.allNodes('TransformGeo'):\n            transformGeoList.append(n.name())\n            zPosList.append(n.knob('translate').value(2))\n\n        uniqueZValues = list(set(zPosList))\n        uniqueZValues.sort()\n        #print uniqueZValues\n        #print len(uniqueZValues)\n\n        organizedList = \[]\n        for n in range(len(uniqueZValues)):        \n            for n2 in nuke.allNodes('TransformGeo'):           \n                if uniqueZValues\[n] == n2.knob('translate').value(2):\n                    organizedList.append(n2.name())\n\n        #print organizedList\n        \n        \n        widthValue = int(nuke.thisNode().knob('width').value())\n        depthValue = int(nuke.thisNode().knob('depth').value())\n        #print widthValue\n        #print depthValue\n\n        chunks = \[organizedList\[x:x+widthValue] for x in xrange(0, len(organizedList), widthValue)]\n        #print chunks\n\n    \n        #print len(chunks\[0])\n        #print chunks\[0]\n\n        #print len(chunks)\n        #print len(chunks\[19])\n        #print chunks\n\n        for n in range(depthValue):\n            #print n\n            for n2 in chunks\[n]:\n             #   print n2\n                nuke.toNode(n2).knob('translate').setValue(uniqueZValues\[n] + (int(n) * (zSpacingValue + 1)) - nuke.toNode(n2).knob('translate').value(2) + 10, 2)\n\n\n\n\n\n\n\n#INPUT TYPE\n\ntry:\n\n    if nuke.thisNode().knob('inputtype').value() == '2D':\n        with nuke.thisNode():\n            for n in nuke.allNodes('Switch'):\n                if n.knob('label').value() == 'Input Type':\n                    n.knob('which').setValue(0)\n    \n    \n    elif nuke.thisNode().knob('inputtype').value() == '3D':\n        with nuke.thisNode():\n            for n in nuke.allNodes('Switch'):\n                if n.knob('label').value() == 'Input Type':\n                    n.knob('which').setValue(1)\n\nexcept:\n    pass\n\n\n\n###########################################################################################################################################################################\n\n\n\n\n\n\n\n\n\n"
 tile_color 0xff5f00ff
 note_font "Verdana Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold"
 selected true
 xpos -2707
 ypos -60
 addUserKnob {20 User}
 addUserKnob {22 setup l "Setup System" T "#CROWD GENERATOR\n#SETUP CHUNK\n#PYTHON SCRIPT CREATED BY PEDRO ANDRADE\n#ALL RIGHTS RESERVED\n#2016\n\nimport nuke\nimport random\n\n\n#NR SELECTED NODES\nnoNodes = int(len(nuke.root().selectedNodes())-1)\n\n\n#CREATING DEFINITION PANEL\npanel = nuke.Panel('Crowd Generator Inputs')\npanel.addSingleLineInput('Nr of Inputs', noNodes)\npanel.addSingleLineInput('Width', '0')\npanel.addSingleLineInput('Depth', '0')\n\nif panel.show():\n\n    numberInputs = int(panel.value('Nr of Inputs'))\n    widthValue = int(panel.value('Width'))\n    dephtValue = int(panel.value('Depth'))\n\n    if (widthValue * dephtValue) < numberInputs:\n        nuke.message('You cannot have more inputs than total amount of generated individuals.\\n\\nYou chose %s inputs against a total of %s individuals.' %(numberInputs, int(widthValue * dephtValue)))\n\n\n    else:\n\n\n        #VALUE IN PANEL\n        nuke.thisNode().knob('width').setValue(int(str(widthValue)))\n        nuke.thisNode().knob('depth').setValue(int(str(dephtValue)))\n        #nuke.thisNode().knob('inputs').setValue(int(str(numberInputs)))\n\n\n        #RESET VALUES IN PANEL\n        nuke.thisNode().knob('density').setValue(100)\n        nuke.thisNode().knob('scale').setValue(1)\n        nuke.thisNode().knob('xzdisplacement').setValue(0)\n        nuke.thisNode().knob('xspacing').setValue(0)\n        nuke.thisNode().knob('zspacing').setValue(0)\n        nuke.thisNode().knob('yspacing').setValue(0)\n        nuke.thisNode().knob('inputtype').setValue('2D')\n\n\n        with nuke.thisNode():\n\n\n            #CLEANING EVERYTHIGN INSIDE\n            for n in nuke.allNodes():\n                if not n.Class() == 'Output':\n                    nuke.delete(n)\n        \n        \n        \n            #CREATING AXIS\n            for n in range(widthValue ):\n                for n2 in range(dephtValue):\n                    axisNode = nuke.nodes.Axis2()\n                    axisNode.knob('translate').setValue(n+10, 0)\n                    axisNode.knob('translate').setValue(n2+10, 2)\n            \n                          \n            \n            #CREATING INPUTS        \n            for n in range(numberInputs):\n                inputNodes = nuke.nodes.Input()\n            \n            \n            \n            #CREATING CARDS\n                cardNodes = nuke.nodes.Card2()\n                cardNodes.knob('rows').setValue(1)\n                cardNodes.knob('columns').setValue(1)\n                cardNodes.setInput(0, inputNodes)\n\n\n            #CREATING TYPE SWITCHES\n                typeSwitchNode = nuke.nodes.Switch()\n                typeSwitchNode.knob('label').setValue('Input Type')\n                typeSwitchNode.setInput(0, cardNodes)\n                typeSwitchNode.setInput(1, inputNodes)\n            \n            \n            #CREATING TRANSFORM GEO / ON OFF SWITCHES AND CONNECTING THE TOGETHER\n            for n in nuke.allNodes('Switch'):\n        \n                transformGeoNodesList = \[]\n                for n2 in range(int((widthValue * dephtValue) / numberInputs)):\n            \n                    transformGeoNodes = nuke.nodes.TransformGeo()    \n                    transformGeoNodes.setInput(0, n)\n                    transformGeoNodesList.append(transformGeoNodes.name())\n        \n                swicthNodesList = \[]\n                for n in transformGeoNodesList:\n                    switchNodes = nuke.nodes.Switch()\n                    switchNodes.knob('label').setValue('ON / OFF')\n                    switchNodes.setInput(0, nuke.toNode(n))\n                    swicthNodesList.append(switchNodes.name())\n        \n                 \n            #CREATING PRE SCENES\n                newSceneList = \[]\n                for n3 in range(int(len(swicthNodesList) / len(swicthNodesList))):\n                    newScene = nuke.nodes.Scene()\n                    newSceneList.append(newScene.name())\n        \n                for n4 in newSceneList:\n                    nuke.toNode(n4).knob('selected').setValue(True)\n        \n                for n5 in swicthNodesList:\n                    nuke.toNode(n5).knob('selected').setValue(True)\n        \n                nuke.connectNodes(False, False)\n        \n                for n6 in nuke.allNodes():\n                    n6.knob('selected').setValue(False)\n                \n                  \n            #CREATE REMAINDER TRANSFORM GEOS AND SWITCHES\n            newTransformGeoNodesList = \[]\n            for n in range (len(nuke.allNodes('Axis2')) - len(nuke.allNodes('TransformGeo'))):\n                transformGeoNodes = nuke.nodes.TransformGeo()\n                transformGeoNodes.setInput(0, nuke.toNode('Switch1'))\n                newTransformGeoNodesList.append(transformGeoNodes.name())\n        \n        \n            newSwitchesList = \[]\n            for n in newTransformGeoNodesList:\n                switchNodes = nuke.nodes.Switch()\n                switchNodes.knob('label').setValue('ON / OFF')\n                switchNodes.setInput(0, nuke.toNode(n))\n                newSwitchesList.append(switchNodes.name())\n               \n                \n        \n            #GETTING VALUES FROM AXIS TO TRANSFORMGEO\n            axisList = \[]\n            transformGeoList = \[]\n            \n            for n in nuke.allNodes('Axis2'):\n                axisList.append(n.name())\n            \n            for n in nuke.allNodes('TransformGeo'):\n                transformGeoList.append(n.name())\n            \n            for n in range(len(axisList)):\n                nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(axisList\[n]).knob('translate').value(0), 0)\n                nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(axisList\[n]).knob('translate').value(1), 1)\n                nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(axisList\[n]).knob('translate').value(2), 2)\n            \n            \n        \n            #SHUFFLING TRANSFORMGEO POSITION          \n            random.shuffle(axisList)\n            \n            for n in range(len(axisList)):\n                nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(axisList\[n]).knob('translate').value(0), 0)\n                nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(axisList\[n]).knob('translate').value(1), 1)\n                nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(axisList\[n]).knob('translate').value(2), 2)\n            \n            \n            \n            \n            #CREATING MASTER SCENE AND CONNECTING ALL ON/OFF SWITCHES        \n            for n in nuke.allNodes():\n                n.knob('selected').setValue(False)\n            \n            masterScene = nuke.nodes.Scene()\n            masterScene.knob('name').setValue('MASTER_SCENE')\n            masterScene.knob('selected').setValue(True)\n            \n            for n in nuke.allNodes('Scene'):\n                if not n.knob('name').value().startswith('MASTER'):\n                    n.knob('selected').setValue(True)\n        \n            for n in newSwitchesList:\n                nuke.toNode(n).knob('selected').setValue(True)\n            \n            nuke.connectNodes(False, False)\n            \n            for n in nuke.allNodes():\n                n.knob('selected').setValue(False)\n                    \n            \n            \n            #CREATING OUTPUT AND CONNECTING TO MASTER SCENE        \n            outputNode = nuke.toNode('Output1')\n            outputNode.setInput(0, nuke.toNode('MASTER_SCENE'))\n            \n            \n            \n            #CREATING LOOK INPUT AND CONNECTING ALL TRANSFORM GEOS TO IT        \n            lookNode = nuke.nodes.Input(name = 'Look')\n            \n            for n in nuke.allNodes('TransformGeo'):\n                n.setInput(2, nuke.toNode('Look'))\n        \n        \n        \n        \n            #SHUFFLING SWITCHES NAMES\n            randomNumberList = \[]\n            for n in range(len(nuke.allNodes('Switch'))):\n                randomNumberList.append(n)    \n            random.shuffle(randomNumberList)\n        \n            print str(randomNumberList)\n        \n            newSwitchList = \[]\n            for n in nuke.allNodes('Switch'):\n                newSwitchList.append(n.name())\n            random.shuffle(newSwitchList)\n        \n            print str(newSwitchList)\n                \n            for n in range(len(randomNumberList)):\n                nuke.toNode(newSwitchList\[n]).knob('name').setValue(str(randomNumberList\[n]))\n        \n            for n in nuke.allNodes('Switch'):\n                n.knob('name').setValue('Switch' + n.knob('name').value())\n\n\n\n\n\n            #CONNECTING NODES IN DAG\n            toBeConnectedList = \[]\n            toConnectList = \[]\n            for n in nuke.root().selectedNodes():\n\n                if not n.name().startswith('PA_C'):\n                    toBeConnectedList.append(n.name())\n\n                else:\n                    toConnectList.append(n.name())\n                   \n            for n in toConnectList:\n                nuke.toNode(n).knob('selected').setValue(False)\n\n            for n in toBeConnectedList:\n                nuke.toNode(n).knob('selected').setValue(False)\n\n\n            for n in toConnectList:\n                nuke.toNode(n).knob('selected').setValue(True)\n\n            for n in toBeConnectedList:\n                nuke.toNode(n).knob('selected').setValue(True)\n\n\n            if len(toBeConnectedList)>0:\n\n                indexList = \[]\n                for n in range(len(toBeConnectedList)+1):\n                    indexList.append(n)\n\n                indexList.remove(2)\n\n                for n in range(len(indexList)):\n                    nuke.toNode(toConnectList\[0]).setInput(n, nuke.toNode(toBeConnectedList\[n]))\n" +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {4 inputtype l "Input Type" M {2D 3D}}
 addUserKnob {3 total l "Total Visible" +DISABLED}
 addUserKnob {3 width l Width +DISABLED}
 addUserKnob {3 depth l Depth -STARTLINE +DISABLED}
 addUserKnob {26 ""}
 addUserKnob {7 density l "Density (%)" -STARTLINE R 0 100}
 density 100
 addUserKnob {22 shuffle l Shuffle -STARTLINE T "#CROWD GENERATOR\n#SHUFFLE CHUNK\n#PYTHON SCRIPT CREATED BY PEDRO ANDRADE\n#ALL RIGHTS RESERVED\n#2016\n\nimport random\n\nwith nuke.thisNode():\n\n       \n    #GETTING VALUES FROM AXIS TO TRANSFORMGEO\n    \n    transformGeoList = \[]\n    for n in nuke.allNodes('TransformGeo'):\n        transformGeoList.append(n.name())\n    \n    \n    for n in range(len(transformGeoList)):\n        newAxis = nuke.nodes.Axis2()\n        newAxis.knob('tile_color').setValue(1)\n        newAxis.knob('translate').setValue(nuke.toNode(transformGeoList\[n]).knob('translate').value(0), 0)\n        newAxis.knob('translate').setValue(nuke.toNode(transformGeoList\[n]).knob('translate').value(1), 1)\n        newAxis.knob('translate').setValue(nuke.toNode(transformGeoList\[n]).knob('translate').value(2), 2)\n    \n    \n    newAxisList = \[]\n    for n in nuke.allNodes('Axis2'):\n        if n.knob('tile_color').value() == 1:\n            newAxisList.append(n.name())\n    \n    \n    #SHUFFLING TRANSFORMGEO POSITION          \n    random.shuffle(newAxisList)\n    \n    for n in range(len(newAxisList)):\n        nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(newAxisList\[n]).knob('translate').value(0), 0)\n        nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(newAxisList\[n]).knob('translate').value(1), 1)\n        nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(newAxisList\[n]).knob('translate').value(2), 2)  \n    \n    \n    #DELETING NEW AXIS\n    for n in newAxisList:\n        nuke.delete(nuke.toNode(n))\n\n\n"}
 addUserKnob {7 scale l Scale R 1 5}
 scale 1
 addUserKnob {26 ""}
 addUserKnob {7 xspacing l "X Spacing" R -0.99 1}
 addUserKnob {7 yspacing l "Y Spacing" R -0.99 1}
 addUserKnob {7 zspacing l "Z Spacing" R -0.99 1}
 addUserKnob {7 xzdisplacement l "XZ Displacement" R -0.05 0.05}
 addUserKnob {22 resetposition l "Reset Position" T "#CROWD GENERATOR\n#RESET POSITION CHUNK\n#PYTHON SCRIPT CREATED BY PEDRO ANDRADE\n#ALL RIGHTS RESERVED\n#2016\n\nimport random\n\n#RESETING VALUES FROM PANEL\nnuke.thisNode().knob('xzdisplacement').setValue(0)\nnuke.thisNode().knob('xspacing').setValue(0)\nnuke.thisNode().knob('yspacing').setValue(0)\nnuke.thisNode().knob('zspacing').setValue(0)\n\n\n\n#GETTING VALUES FROM AXIS TO TRANSFORMGEO\naxisList = \[]\ntransformGeoList = \[]\n\nfor n in nuke.allNodes('Axis2'):\n    axisList.append(n.name())\n\nfor n in nuke.allNodes('TransformGeo'):\n    transformGeoList.append(n.name())\n\nfor n in range(len(axisList)):\n    nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(axisList\[n]).knob('translate').value(0), 0)\n    nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(axisList\[n]).knob('translate').value(1), 1)\n    nuke.toNode(transformGeoList\[n]).knob('translate').setValue(nuke.toNode(axisList\[n]).knob('translate').value(2), 2)\n" +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 author l "" +STARTLINE T "Crowd Generator v1.1\nCreated by Pedro Andrade\n-2016-"}
 addUserKnob {32 howitworks l "How It Works" T "start https://youtu.be/v6bWVkcWOfE" +STARTLINE}
}
 Scene {
  inputs 0
  name MASTER_SCENE
 }
 Output {
  name Output1
  xpos 200
  ypos 510
 }
 Input {
  inputs 0
  name Look
 }
end_group
